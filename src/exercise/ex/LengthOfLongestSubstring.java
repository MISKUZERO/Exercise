package exercise.ex;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;

public class LengthOfLongestSubstring {

    public static void main(String[] args) {
        String s = "如果是初次接触类似的问题，乍看之下肯定会感觉无从下手。" +
                "当最大的盘子由a移到c后，b上是余下的63个盘子，a为空。因此现在的目标就变成了将这63个盘子由b移到c。这个问题和原来的问题完全一样，只是由a柱换为了b柱，规模由64变为了63。因此可以采用相同的方法，先将上面的62个盘子由b移到a，再将最下面的盘子移到c……对照下面的过程，试着是否能找到规律：" +
                "func:" +
                "if n!=0 then            ;预定值" +
                "  func(n-1, a, c, b)    ;将n-1个盘子由a移动到b，以c为辅助柱子（注意参数顺序）" +
                "  move a[n] to c        ;将a上的最后一个盘子移动到c" +
                "  func(n-1, b, a, c)    ;将n-1个盘子由b移动到c，以a为辅助柱子" +
                "endif                   ;完成" +
                "" +
                "func中有两个递归调用，它们的规模刚好比n小1。注释说明了每行代码的作用和意图。正如注释里所强调的那样，注意参数的顺序——参数位置不同，其代表的意义也不一样。" +
                "" +
                "第一个递归调用以c作为辅助柱子，这没有问题，因为c柱子的最下面的k个圆盘一定是所有圆盘中最大的k个，因此将其作为辅助柱子不会出现大圆盘在小圆盘之上的情况。" +
                "下面是使用Java实现的汉诺塔程序，程序使用Stack实例来保存每个柱子上" +
                "研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。。而不是简单地使每个并行分支移动相同数量的盘子。盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。是简单地使每个并行分支移动相同数量的盘子。一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。现并行方式研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。要注意的是，成功移动第一个盘子的步数是最多的，研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。占到总步数研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。而不是简单地使每个并行分支移动相同数量的盘子。时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。并研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子研究如研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。行分支移动相同数量的盘子。的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。量的盘子。时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使研究如何使用并行算法解决汉诺研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要研究研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。多的，研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。最多的，占到总步数的1/2；而第研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。地使每个并行分支移动相同数量的盘子。研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简研究如何使用并行算法解决汉诺塔问题。例如，64个盘子，每次成功将一个盘子移动到目标柱子上的过程都是独立的。因此可以分别并行地计算。\n" +
                "不过需要注意的是，成功移动第一个盘子的步数是最多的，占到总步数的1/2；而第二个盘子需要总步数的1/4……最后一个盘子仅需1步。\n" +
                "所以在实现并行方式时要考虑这种差异。而不是简单地使每个并行分支移动相同数量的盘子。单地使每个并行分支移动相同数量的盘子。的盘子及它们的顺序。Stack是队列的一种，其中的元素遵循“先进先出”（FIFO）的原则，即不允许从队尾取元素。这种队列通常也称为“栈”。栈对元素的进出约定与汉诺塔的规则一致.resolve方法用来移动盘子，参数n表示要移动的盘子的数量，a是盘子所在的柱子，b是辅助柱子，c是目标柱子。注意此方法会首先检查参数n，当n为0时直接返回，这就是前面所说的“预定值”。如果没有对预定值的判断，resolve的递归过程将不会自然终止，而是无限进行下去，直到塞满系统内存堆栈而导致程序奔溃。另外要注意的是程序将盘子的初始数量设为32个，你可以修改该值，但建议不要设置的过大，原因正如前面所计算的那样，如果采用64个圆盘，你将至少需要数百年才能看到结果（更可能的结果是由于步数太多，系统没有足够的内存而导致程序奔溃）。";
        LengthOfLongestSubstring lol = new LengthOfLongestSubstring();
        long l = System.nanoTime();
        int i = lol.lengthOfLongestSubstring(s);
        System.out.println(System.nanoTime() - l);

        l = System.nanoTime();
        int in = lol.lengthOfLongestSubstringNew(s);
        System.out.println(System.nanoTime() - l);

        l = System.nanoTime();
        int in1 = lol.lengthOfLongestSubstringNew1(s);
        System.out.println(System.nanoTime() - l);

        l = System.nanoTime();
        int in2 = lol.lengthOfLongestSubstringNew2(s);
        System.out.println(System.nanoTime() - l);

        System.out.println(i);
        System.out.println(in);
        System.out.println(in1);
        System.out.println(in2);
    }

    public int lengthOfLongestSubstring(String s) {
        int max = 0;
        int length = s.length();
        for (int i = 0; i < length; i++) {
            HashMap<Character, Integer> hashMap = new HashMap<>();
            int count = 0;
            for (int j = i; j < length; j++)
                if (hashMap.putIfAbsent(s.charAt(j), 0) == null)
                    count++;
                else //重复
                    break;
            max = Math.max(max, count);
        }
        return max;
    }

    public int lengthOfLongestSubstringNew(String s) {
        HashMap<Character, Integer> hashMap = new HashMap<>();
        int max = 0;
        int length = s.length();
        for (int i = 0, j = 0; i < length; i++) {
            for (; j < length; j++)
                if (hashMap.putIfAbsent(s.charAt(j), 0) != null) //重复
                    break;
            max = Math.max(max, hashMap.size());
            hashMap.remove(s.charAt(i));
        }
        return max;
    }

    public int lengthOfLongestSubstringNew1(String s) {
        HashSet<Character> hashSet = new HashSet<>();
        int maxLen = 0;
        int length = s.length();
        if (length == 0) return 0;
        char c = s.charAt(0);
        int i = 0, j = 0;
        while (i != length) {
            while (hashSet.contains(c))
                hashSet.remove(s.charAt(j++));
            while (i != length && hashSet.add((c = s.charAt(i)))) i++;
            maxLen = Math.max(maxLen, hashSet.size());
        }
        return maxLen;
    }

    public int lengthOfLongestSubstringNew2(String s) {
        int count = 0, curCount = 0;
        int length = s.length();
        int[] codes = new int[100000];
        Arrays.fill(codes, -1);
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            curCount = Math.min(curCount + 1, i - codes[c]);
            count = Math.max(count, curCount);
            codes[c] = i;
        }
        return count;
    }


}
